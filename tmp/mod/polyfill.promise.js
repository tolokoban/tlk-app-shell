{"intl":"var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n","src":"/** @module polyfill.promise */require( 'polyfill.promise', function(require, module, exports) { var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n    /**\r\n * Polyfill for Promise...\r\n */\r\n/*!\r\n * @overview es6-promise - a tiny implementation of Promises/A+.\r\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\r\n * @license   Licensed under MIT license\r\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\r\n * @version   2.0.0\r\n */\r\n\r\nif (!window.Promise) {\r\n    (function() {\r\n        \"use strict\";\r\n\r\n        function $$utils$$objectOrFunction(x) {\r\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\r\n        }\r\n\r\n        function $$utils$$isFunction(x) {\r\n            return typeof x === 'function';\r\n        }\r\n\r\n        function $$utils$$isMaybeThenable(x) {\r\n            return typeof x === 'object' && x !== null;\r\n        }\r\n\r\n        var $$utils$$_isArray;\r\n\r\n        if (!Array.isArray) {\r\n            $$utils$$_isArray = function (x) {\r\n                return Object.prototype.toString.call(x) === '[object Array]';\r\n            };\r\n        } else {\r\n            $$utils$$_isArray = Array.isArray;\r\n        }\r\n\r\n        var $$utils$$isArray = $$utils$$_isArray;\r\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\r\n        function $$utils$$F() { }\r\n\r\n        var $$utils$$o_create = (Object.create || function (o) {\r\n            if (arguments.length > 1) {\r\n                throw new Error('Second argument not supported');\r\n            }\r\n            if (typeof o !== 'object') {\r\n                throw new TypeError('Argument must be an object');\r\n            }\r\n            $$utils$$F.prototype = o;\r\n            return new $$utils$$F();\r\n        });\r\n\r\n        var $$asap$$len = 0;\r\n\r\n        var $$asap$$default = function asap(callback, arg) {\r\n            $$asap$$queue[$$asap$$len] = callback;\r\n            $$asap$$queue[$$asap$$len + 1] = arg;\r\n            $$asap$$len += 2;\r\n            if ($$asap$$len === 2) {\r\n                // If len is 1, that means that we need to schedule an async flush.\r\n                // If additional callbacks are queued before the queue is flushed, they\r\n                // will be processed by this flush that we are scheduling.\r\n                $$asap$$scheduleFlush();\r\n            }\r\n        };\r\n\r\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\r\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\r\n\r\n        // test for web worker but not in IE10\r\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\r\n            typeof importScripts !== 'undefined' &&\r\n            typeof MessageChannel !== 'undefined';\r\n\r\n        // node\r\n        function $$asap$$useNextTick() {\r\n            return function() {\r\n                process.nextTick($$asap$$flush);\r\n            };\r\n        }\r\n\r\n        function $$asap$$useMutationObserver() {\r\n            var iterations = 0;\r\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\r\n            var node = document.createTextNode('');\r\n            observer.observe(node, { characterData: true });\r\n\r\n            return function() {\r\n                node.data = (iterations = ++iterations % 2);\r\n            };\r\n        }\r\n\r\n        // web worker\r\n        function $$asap$$useMessageChannel() {\r\n            var channel = new MessageChannel();\r\n            channel.port1.onmessage = $$asap$$flush;\r\n            return function () {\r\n                channel.port2.postMessage(0);\r\n            };\r\n        }\r\n\r\n        function $$asap$$useSetTimeout() {\r\n            return function() {\r\n                setTimeout($$asap$$flush, 1);\r\n            };\r\n        }\r\n\r\n        var $$asap$$queue = new Array(1000);\r\n\r\n        function $$asap$$flush() {\r\n            for (var i = 0; i < $$asap$$len; i+=2) {\r\n                var callback = $$asap$$queue[i];\r\n                var arg = $$asap$$queue[i+1];\r\n\r\n                callback(arg);\r\n\r\n                $$asap$$queue[i] = undefined;\r\n                $$asap$$queue[i+1] = undefined;\r\n            }\r\n\r\n            $$asap$$len = 0;\r\n        }\r\n\r\n        var $$asap$$scheduleFlush;\r\n\r\n        // Decide what async method to use to triggering processing of queued callbacks:\r\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\r\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\r\n        } else if ($$asap$$BrowserMutationObserver) {\r\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\r\n        } else if ($$asap$$isWorker) {\r\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\r\n        } else {\r\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\r\n        }\r\n\r\n        function $$$internal$$noop() {}\r\n        var $$$internal$$PENDING   = void 0;\r\n        var $$$internal$$FULFILLED = 1;\r\n        var $$$internal$$REJECTED  = 2;\r\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\r\n\r\n        function $$$internal$$selfFullfillment() {\r\n            return new TypeError(\"You cannot resolve a promise with itself\");\r\n        }\r\n\r\n        function $$$internal$$cannotReturnOwn() {\r\n            return new TypeError('A promises callback cannot return that same promise.')\r\n        }\r\n\r\n        function $$$internal$$getThen(promise) {\r\n            try {\r\n                return promise.then;\r\n            } catch(error) {\r\n                $$$internal$$GET_THEN_ERROR.error = error;\r\n                return $$$internal$$GET_THEN_ERROR;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\r\n            try {\r\n                then.call(value, fulfillmentHandler, rejectionHandler);\r\n            } catch(e) {\r\n                return e;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\r\n            $$asap$$default(function(promise) {\r\n                var sealed = false;\r\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\r\n                    if (sealed) { return; }\r\n                    sealed = true;\r\n                    if (thenable !== value) {\r\n                        $$$internal$$resolve(promise, value);\r\n                    } else {\r\n                        $$$internal$$fulfill(promise, value);\r\n                    }\r\n                }, function(reason) {\r\n                    if (sealed) { return; }\r\n                    sealed = true;\r\n\r\n                    $$$internal$$reject(promise, reason);\r\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\r\n\r\n                if (!sealed && error) {\r\n                    sealed = true;\r\n                    $$$internal$$reject(promise, error);\r\n                }\r\n            }, promise);\r\n        }\r\n\r\n        function $$$internal$$handleOwnThenable(promise, thenable) {\r\n            if (thenable._state === $$$internal$$FULFILLED) {\r\n                $$$internal$$fulfill(promise, thenable._result);\r\n            } else if (promise._state === $$$internal$$REJECTED) {\r\n                $$$internal$$reject(promise, thenable._result);\r\n            } else {\r\n                $$$internal$$subscribe(thenable, undefined, function(value) {\r\n                    $$$internal$$resolve(promise, value);\r\n                }, function(reason) {\r\n                    $$$internal$$reject(promise, reason);\r\n                });\r\n            }\r\n        }\r\n\r\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\r\n            if (maybeThenable.constructor === promise.constructor) {\r\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\r\n            } else {\r\n                var then = $$$internal$$getThen(maybeThenable);\r\n\r\n                if (then === $$$internal$$GET_THEN_ERROR) {\r\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\r\n                } else if (then === undefined) {\r\n                    $$$internal$$fulfill(promise, maybeThenable);\r\n                } else if ($$utils$$isFunction(then)) {\r\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\r\n                } else {\r\n                    $$$internal$$fulfill(promise, maybeThenable);\r\n                }\r\n            }\r\n        }\r\n\r\n        function $$$internal$$resolve(promise, value) {\r\n            if (promise === value) {\r\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\r\n            } else if ($$utils$$objectOrFunction(value)) {\r\n                $$$internal$$handleMaybeThenable(promise, value);\r\n            } else {\r\n                $$$internal$$fulfill(promise, value);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$publishRejection(promise) {\r\n            if (promise._onerror) {\r\n                promise._onerror(promise._result);\r\n            }\r\n\r\n            $$$internal$$publish(promise);\r\n        }\r\n\r\n        function $$$internal$$fulfill(promise, value) {\r\n            if (promise._state !== $$$internal$$PENDING) { return; }\r\n\r\n            promise._result = value;\r\n            promise._state = $$$internal$$FULFILLED;\r\n\r\n            if (promise._subscribers.length === 0) {\r\n            } else {\r\n                $$asap$$default($$$internal$$publish, promise);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$reject(promise, reason) {\r\n            if (promise._state !== $$$internal$$PENDING) { return; }\r\n            promise._state = $$$internal$$REJECTED;\r\n            promise._result = reason;\r\n\r\n            $$asap$$default($$$internal$$publishRejection, promise);\r\n        }\r\n\r\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\r\n            var subscribers = parent._subscribers;\r\n            var length = subscribers.length;\r\n\r\n            parent._onerror = null;\r\n\r\n            subscribers[length] = child;\r\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\r\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\r\n\r\n            if (length === 0 && parent._state) {\r\n                $$asap$$default($$$internal$$publish, parent);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$publish(promise) {\r\n            var subscribers = promise._subscribers;\r\n            var settled = promise._state;\r\n\r\n            if (subscribers.length === 0) { return; }\r\n\r\n            var child, callback, detail = promise._result;\r\n\r\n            for (var i = 0; i < subscribers.length; i += 3) {\r\n                child = subscribers[i];\r\n                callback = subscribers[i + settled];\r\n\r\n                if (child) {\r\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\r\n                } else {\r\n                    callback(detail);\r\n                }\r\n            }\r\n\r\n            promise._subscribers.length = 0;\r\n        }\r\n\r\n        function $$$internal$$ErrorObject() {\r\n            this.error = null;\r\n        }\r\n\r\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\r\n\r\n        function $$$internal$$tryCatch(callback, detail) {\r\n            try {\r\n                return callback(detail);\r\n            } catch(e) {\r\n                $$$internal$$TRY_CATCH_ERROR.error = e;\r\n                return $$$internal$$TRY_CATCH_ERROR;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\r\n            var hasCallback = $$utils$$isFunction(callback),\r\n            value, error, succeeded, failed;\r\n\r\n            if (hasCallback) {\r\n                value = $$$internal$$tryCatch(callback, detail);\r\n\r\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\r\n                    failed = true;\r\n                    error = value.error;\r\n                    value = null;\r\n                } else {\r\n                    succeeded = true;\r\n                }\r\n\r\n                if (promise === value) {\r\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\r\n                    return;\r\n                }\r\n\r\n            } else {\r\n                value = detail;\r\n                succeeded = true;\r\n            }\r\n\r\n            if (promise._state !== $$$internal$$PENDING) {\r\n                // noop\r\n            } else if (hasCallback && succeeded) {\r\n                $$$internal$$resolve(promise, value);\r\n            } else if (failed) {\r\n                $$$internal$$reject(promise, error);\r\n            } else if (settled === $$$internal$$FULFILLED) {\r\n                $$$internal$$fulfill(promise, value);\r\n            } else if (settled === $$$internal$$REJECTED) {\r\n                $$$internal$$reject(promise, value);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$initializePromise(promise, resolver) {\r\n            try {\r\n                resolver(function resolvePromise(value){\r\n                    $$$internal$$resolve(promise, value);\r\n                }, function rejectPromise(reason) {\r\n                    $$$internal$$reject(promise, reason);\r\n                });\r\n            } catch(e) {\r\n                $$$internal$$reject(promise, e);\r\n            }\r\n        }\r\n\r\n        function $$$enumerator$$makeSettledResult(state, position, value) {\r\n            if (state === $$$internal$$FULFILLED) {\r\n                return {\r\n                    state: 'fulfilled',\r\n                    value: value\r\n                };\r\n            } else {\r\n                return {\r\n                    state: 'rejected',\r\n                    reason: value\r\n                };\r\n            }\r\n        }\r\n\r\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\r\n            this._instanceConstructor = Constructor;\r\n            this.promise = new Constructor($$$internal$$noop, label);\r\n            this._abortOnReject = abortOnReject;\r\n\r\n            if (this._validateInput(input)) {\r\n                this._input     = input;\r\n                this.length     = input.length;\r\n                this._remaining = input.length;\r\n\r\n                this._init();\r\n\r\n                if (this.length === 0) {\r\n                    $$$internal$$fulfill(this.promise, this._result);\r\n                } else {\r\n                    this.length = this.length || 0;\r\n                    this._enumerate();\r\n                    if (this._remaining === 0) {\r\n                        $$$internal$$fulfill(this.promise, this._result);\r\n                    }\r\n                }\r\n            } else {\r\n                $$$internal$$reject(this.promise, this._validationError());\r\n            }\r\n        }\r\n\r\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\r\n            return $$utils$$isArray(input);\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\r\n            return new Error('Array Methods must be provided an Array');\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._init = function() {\r\n            this._result = new Array(this.length);\r\n        };\r\n\r\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\r\n\r\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\r\n            var length  = this.length;\r\n            var promise = this.promise;\r\n            var input   = this._input;\r\n\r\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\r\n                this._eachEntry(input[i], i);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\r\n            var c = this._instanceConstructor;\r\n            if ($$utils$$isMaybeThenable(entry)) {\r\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\r\n                    entry._onerror = null;\r\n                    this._settledAt(entry._state, i, entry._result);\r\n                } else {\r\n                    this._willSettleAt(c.resolve(entry), i);\r\n                }\r\n            } else {\r\n                this._remaining--;\r\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\r\n            var promise = this.promise;\r\n\r\n            if (promise._state === $$$internal$$PENDING) {\r\n                this._remaining--;\r\n\r\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\r\n                    $$$internal$$reject(promise, value);\r\n                } else {\r\n                    this._result[i] = this._makeResult(state, i, value);\r\n                }\r\n            }\r\n\r\n            if (this._remaining === 0) {\r\n                $$$internal$$fulfill(promise, this._result);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\r\n            return value;\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\r\n            var enumerator = this;\r\n\r\n            $$$internal$$subscribe(promise, undefined, function(value) {\r\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\r\n            }, function(reason) {\r\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\r\n            });\r\n        };\r\n\r\n        var $$promise$all$$default = function all(entries, label) {\r\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\r\n        };\r\n\r\n        var $$promise$race$$default = function race(entries, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n\r\n            if (!$$utils$$isArray(entries)) {\r\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\r\n                return promise;\r\n            }\r\n\r\n            var length = entries.length;\r\n\r\n            function onFulfillment(value) {\r\n                $$$internal$$resolve(promise, value);\r\n            }\r\n\r\n            function onRejection(reason) {\r\n                $$$internal$$reject(promise, reason);\r\n            }\r\n\r\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\r\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\r\n            }\r\n\r\n            return promise;\r\n        };\r\n\r\n        var $$promise$resolve$$default = function resolve(object, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n\r\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\r\n                return object;\r\n            }\r\n\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n            $$$internal$$resolve(promise, object);\r\n            return promise;\r\n        };\r\n\r\n        var $$promise$reject$$default = function reject(reason, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n            $$$internal$$reject(promise, reason);\r\n            return promise;\r\n        };\r\n\r\n        var $$es6$promise$promise$$counter = 0;\r\n\r\n        function $$es6$promise$promise$$needsResolver() {\r\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\r\n        }\r\n\r\n        function $$es6$promise$promise$$needsNew() {\r\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\r\n        }\r\n\r\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\r\n\r\n        /**\r\n         Promise objects represent the eventual result of an asynchronous operation. The\r\n         primary way of interacting with a promise is through its `then` method, which\r\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\r\n         why the promise cannot be fulfilled.\r\n\r\n         Terminology\r\n         -----------\r\n\r\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\r\n         - `thenable` is an object or function that defines a `then` method.\r\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\r\n         - `exception` is a value that is thrown using the throw statement.\r\n         - `reason` is a value that indicates why a promise was rejected.\r\n         - `settled` the final resting state of a promise, fulfilled or rejected.\r\n\r\n         A promise can be in one of three states: pending, fulfilled, or rejected.\r\n\r\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\r\n         state.  Promises that are rejected have a rejection reason and are in the\r\n         rejected state.  A fulfillment value is never a thenable.\r\n\r\n         Promises can also be said to *resolve* a value.  If this value is also a\r\n         promise, then the original promise's settled state will match the value's\r\n         settled state.  So a promise that *resolves* a promise that rejects will\r\n         itself reject, and a promise that *resolves* a promise that fulfills will\r\n         itself fulfill.\r\n\r\n\r\n         Basic Usage:\r\n         ------------\r\n\r\n         ```js\r\n         var promise = new Promise(function(resolve, reject) {\r\n         // on success\r\n         resolve(value);\r\n\r\n         // on failure\r\n         reject(reason);\r\n         });\r\n\r\n         promise.then(function(value) {\r\n         // on fulfillment\r\n         }, function(reason) {\r\n         // on rejection\r\n         });\r\n         ```\r\n\r\n         Advanced Usage:\r\n         ---------------\r\n\r\n         Promises shine when abstracting away asynchronous interactions such as\r\n         `XMLHttpRequest`s.\r\n\r\n         ```js\r\n         function getJSON(url) {\r\n         return new Promise(function(resolve, reject){\r\n         var xhr = new XMLHttpRequest();\r\n\r\n         xhr.open('GET', url);\r\n         xhr.onreadystatechange = handler;\r\n         xhr.responseType = 'json';\r\n         xhr.setRequestHeader('Accept', 'application/json');\r\n         xhr.send();\r\n\r\n         function handler() {\r\n         if (this.readyState === this.DONE) {\r\n         if (this.status === 200) {\r\n         resolve(this.response);\r\n         } else {\r\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\r\n         }\r\n         }\r\n         };\r\n         });\r\n         }\r\n\r\n         getJSON('/posts.json').then(function(json) {\r\n         // on fulfillment\r\n         }, function(reason) {\r\n         // on rejection\r\n         });\r\n         ```\r\n\r\n         Unlike callbacks, promises are great composable primitives.\r\n\r\n         ```js\r\n         Promise.all([\r\n         getJSON('/posts'),\r\n         getJSON('/comments')\r\n         ]).then(function(values){\r\n         values[0] // => postsJSON\r\n         values[1] // => commentsJSON\r\n\r\n         return values;\r\n         });\r\n         ```\r\n\r\n         @class Promise\r\n         @param {function} resolver\r\n         @param {String} label optional string for labeling the promise.\r\n         Useful for tooling.\r\n         @constructor\r\n         */\r\n        function $$es6$promise$promise$$Promise(resolver, label) {\r\n            this._id = $$es6$promise$promise$$counter++;\r\n            this._label = label;\r\n            this._state = undefined;\r\n            this._result = undefined;\r\n            this._subscribers = [];\r\n\r\n            if ($$$internal$$noop !== resolver) {\r\n                if (!$$utils$$isFunction(resolver)) {\r\n                    $$es6$promise$promise$$needsResolver();\r\n                }\r\n\r\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\r\n                    $$es6$promise$promise$$needsNew();\r\n                }\r\n\r\n                $$$internal$$initializePromise(this, resolver);\r\n            }\r\n        }\r\n\r\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\r\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\r\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\r\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\r\n\r\n        $$es6$promise$promise$$Promise.prototype = {\r\n            constructor: $$es6$promise$promise$$Promise,\r\n\r\n            /**\r\n             The primary way of interacting with a promise is through its `then` method,\r\n             which registers callbacks to receive either a promise's eventual value or the\r\n             reason why the promise cannot be fulfilled.\r\n\r\n             ```js\r\n             findUser().then(function(user){\r\n             // user is available\r\n             }, function(reason){\r\n             // user is unavailable, and you are given the reason why\r\n             });\r\n             ```\r\n\r\n             Chaining\r\n             --------\r\n\r\n             The return value of `then` is itself a promise.  This second, 'downstream'\r\n             promise is resolved with the return value of the first promise's fulfillment\r\n             or rejection handler, or rejected if the handler throws an exception.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return user.name;\r\n             }, function (reason) {\r\n             return 'default name';\r\n             }).then(function (userName) {\r\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\r\n             // will be `'default name'`\r\n             });\r\n\r\n             findUser().then(function (user) {\r\n             throw new Error('Found user, but still unhappy');\r\n             }, function (reason) {\r\n             throw new Error('`findUser` rejected and we're unhappy');\r\n             }).then(function (value) {\r\n             // never reached\r\n             }, function (reason) {\r\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\r\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\r\n             });\r\n             ```\r\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             throw new PedagogicalException('Upstream error');\r\n             }).then(function (value) {\r\n             // never reached\r\n             }).then(function (value) {\r\n             // never reached\r\n             }, function (reason) {\r\n             // The `PedgagocialException` is propagated all the way down to here\r\n             });\r\n             ```\r\n\r\n             Assimilation\r\n             ------------\r\n\r\n             Sometimes the value you want to propagate to a downstream promise can only be\r\n             retrieved asynchronously. This can be achieved by returning a promise in the\r\n             fulfillment or rejection handler. The downstream promise will then be pending\r\n             until the returned promise is settled. This is called *assimilation*.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return findCommentsByAuthor(user);\r\n             }).then(function (comments) {\r\n             // The user's comments are now available\r\n             });\r\n             ```\r\n\r\n             If the assimliated promise rejects, then the downstream promise will also reject.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return findCommentsByAuthor(user);\r\n             }).then(function (comments) {\r\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\r\n             }, function (reason) {\r\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\r\n             });\r\n             ```\r\n\r\n             Simple Example\r\n             --------------\r\n\r\n             Synchronous Example\r\n\r\n             ```javascript\r\n             var result;\r\n\r\n             try {\r\n             result = findResult();\r\n             // success\r\n             } catch(reason) {\r\n             // failure\r\n             }\r\n             ```\r\n\r\n             Errback Example\r\n\r\n             ```js\r\n             findResult(function(result, err){\r\n             if (err) {\r\n             // failure\r\n             } else {\r\n             // success\r\n             }\r\n             });\r\n             ```\r\n\r\n             Promise Example;\r\n\r\n             ```javascript\r\n             findResult().then(function(result){\r\n             // success\r\n             }, function(reason){\r\n             // failure\r\n             });\r\n             ```\r\n\r\n             Advanced Example\r\n             --------------\r\n\r\n             Synchronous Example\r\n\r\n             ```javascript\r\n             var author, books;\r\n\r\n             try {\r\n             author = findAuthor();\r\n             books  = findBooksByAuthor(author);\r\n             // success\r\n             } catch(reason) {\r\n             // failure\r\n             }\r\n             ```\r\n\r\n             Errback Example\r\n\r\n             ```js\r\n\r\n             function foundBooks(books) {\r\n\r\n             }\r\n\r\n             function failure(reason) {\r\n\r\n             }\r\n\r\n             findAuthor(function(author, err){\r\n             if (err) {\r\n             failure(err);\r\n             // failure\r\n             } else {\r\n             try {\r\n             findBoooksByAuthor(author, function(books, err) {\r\n             if (err) {\r\n             failure(err);\r\n             } else {\r\n             try {\r\n             foundBooks(books);\r\n             } catch(reason) {\r\n             failure(reason);\r\n             }\r\n             }\r\n             });\r\n             } catch(error) {\r\n             failure(err);\r\n             }\r\n             // success\r\n             }\r\n             });\r\n             ```\r\n\r\n             Promise Example;\r\n\r\n             ```javascript\r\n             findAuthor().\r\n             then(findBooksByAuthor).\r\n             then(function(books){\r\n             // found books\r\n             }).catch(function(reason){\r\n             // something went wrong\r\n             });\r\n             ```\r\n\r\n             @method then\r\n             @param {Function} onFulfilled\r\n             @param {Function} onRejected\r\n             @param {String} label optional string for labeling the promise.\r\n             Useful for tooling.\r\n             @return {Promise}\r\n             */\r\n            then: function(onFulfillment, onRejection, label) {\r\n                var parent = this;\r\n                var state = parent._state;\r\n\r\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\r\n                    return this;\r\n                }\r\n\r\n                parent._onerror = null;\r\n\r\n                var child = new this.constructor($$$internal$$noop, label);\r\n                var result = parent._result;\r\n\r\n                if (state) {\r\n                    var callback = arguments[state - 1];\r\n                    $$asap$$default(function(){\r\n                        $$$internal$$invokeCallback(state, child, callback, result);\r\n                    });\r\n                } else {\r\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\r\n                }\r\n\r\n                return child;\r\n            },\r\n\r\n            /**\r\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\r\n             as the catch block of a try/catch statement.\r\n\r\n             ```js\r\n             function findAuthor(){\r\n             throw new Error('couldn't find that author');\r\n             }\r\n\r\n             // synchronous\r\n             try {\r\n             findAuthor();\r\n             } catch(reason) {\r\n             // something went wrong\r\n             }\r\n\r\n             // async with promises\r\n             findAuthor().catch(function(reason){\r\n             // something went wrong\r\n             });\r\n             ```\r\n\r\n             @method catch\r\n             @param {Function} onRejection\r\n             @param {String} label optional string for labeling the promise.\r\n             Useful for tooling.\r\n             @return {Promise}\r\n             */\r\n            'catch': function(onRejection, label) {\r\n                return this.then(null, onRejection, label);\r\n            }\r\n        };\r\n\r\n        var $$es6$promise$polyfill$$default = function polyfill() {\r\n            var local;\r\n\r\n            if (typeof global !== 'undefined') {\r\n                local = global;\r\n            } else if (typeof window !== 'undefined' && window.document) {\r\n                local = window;\r\n            } else {\r\n                local = self;\r\n            }\r\n\r\n            var es6PromiseSupport =\r\n                \"Promise\" in local &&\r\n                // Some of these methods are missing from\r\n                // Firefox/Chrome experimental implementations\r\n                \"resolve\" in local.Promise &&\r\n                \"reject\" in local.Promise &&\r\n                \"all\" in local.Promise &&\r\n                \"race\" in local.Promise &&\r\n                // Older version of the spec had a resolver object\r\n                // as the arg rather than a function\r\n                (function() {\r\n                    var resolve;\r\n                    new local.Promise(function(r) { resolve = r; });\r\n                    return $$utils$$isFunction(resolve);\r\n                }());\r\n\r\n            if (!es6PromiseSupport) {\r\n                local.Promise = $$es6$promise$promise$$default;\r\n            }\r\n        };\r\n\r\n        var es6$promise$umd$$ES6Promise = {\r\n            Promise: $$es6$promise$promise$$default,\r\n            polyfill: $$es6$promise$polyfill$$default\r\n        };\r\n\r\n        // Calling polyfill.\r\n        $$es6$promise$polyfill$$default();\r\n\r\n        /* global define:true module:true window: true */\r\n/*\r\n        if (typeof define === 'function' && define['amd']) {\r\n            define(function() { return es6$promise$umd$$ES6Promise; });\r\n        } else if (typeof module !== 'undefined' && module['exports']) {\r\n            module['exports'] = es6$promise$umd$$ES6Promise;\r\n        } else if (typeof this !== 'undefined') {\r\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\r\n        }\r\n*/\r\n    }).call(this);\r\n}\r\n\r\n\r\n  \r\nmodule.exports._ = _;\n/**\n * @module polyfill.promise\n * @see module:$\n\n */\n});","zip":"require(\"polyfill.promise\",function(t,n,e){var r=function(){function n(){return r(e,arguments)}var e={en:{},fr:{}},r=t(\"$\").intl;return n.all=e,n}();window.Promise||function(){\"use strict\";function t(t){return\"function\"==typeof t||\"object\"==typeof t&&null!==t}function n(t){return\"function\"==typeof t}function e(t){return\"object\"==typeof t&&null!==t}function r(){}function o(){return function(){process.nextTick(c)}}function i(){var t=0,n=new q(c),e=document.createTextNode(\"\");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}function s(){var t=new MessageChannel;return t.port1.onmessage=c,function(){t.port2.postMessage(0)}}function u(){return function(){setTimeout(c,1)}}function c(){for(var t=0;t<D;t+=2){var n=K[t],e=K[t+1];n(e),K[t]=void 0,K[t+1]=void 0}D=0}function a(){}function f(){return new TypeError(\"You cannot resolve a promise with itself\")}function l(){return new TypeError(\"A promises callback cannot return that same promise.\")}function h(t){try{return t.then}catch(t){return $.error=t,$}}function p(t,n,e,r){try{t.call(n,e,r)}catch(t){return t}}function _(t,n,e){Y(function(t){var r=!1,o=p(e,n,function(e){r||(r=!0,n!==e?y(t,e):w(t,e))},function(n){r||(r=!0,b(t,n))},\"Settle: \"+(t._label||\" unknown promise\"));!r&&o&&(r=!0,b(t,o))},t)}function v(t,n){n._state===U?w(t,n._result):t._state===W?b(t,n._result):g(n,void 0,function(n){y(t,n)},function(n){b(t,n)})}function d(t,e){if(e.constructor===t.constructor)v(t,e);else{var r=h(e);r===$?b(t,$.error):void 0===r?w(t,e):n(r)?_(t,e,r):w(t,e)}}function y(n,e){n===e?b(n,f()):t(e)?d(n,e):w(n,e)}function m(t){t._onerror&&t._onerror(t._result),A(t)}function w(t,n){t._state===N&&(t._result=n,t._state=U,0===t._subscribers.length||Y(A,t))}function b(t,n){t._state===N&&(t._state=W,t._result=n,Y(m,t))}function g(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+U]=e,o[i+W]=r,0===i&&t._state&&Y(A,t)}function A(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,s=0;s<n.length;s+=3)r=n[s],o=n[s+e],r?P(e,r,o,i):o(i);t._subscribers.length=0}}function j(){this.error=null}function E(t,n){try{return t(n)}catch(t){return z.error=t,z}}function P(t,e,r,o){var i,s,u,c,a=n(r);if(a){if(i=E(r,o),i===z?(c=!0,s=i.error,i=null):u=!0,e===i)return void b(e,l())}else i=o,u=!0;e._state!==N||(a&&u?y(e,i):c?b(e,s):t===U?w(e,i):t===W&&b(e,i))}function T(t,n){try{n(function(n){y(t,n)},function(n){b(t,n)})}catch(n){b(t,n)}}function S(t,n,e,r){this._instanceConstructor=t,this.promise=new t(a,r),this._abortOnReject=e,this._validateInput(n)?(this._input=n,this.length=n.length,this._remaining=n.length,this._init(),0===this.length?w(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&w(this.promise,this._result))):b(this.promise,this._validationError())}function k(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}function M(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}function O(t,e){this._id=Q++,this._label=e,this._state=void 0,this._result=void 0,this._subscribers=[],a!==t&&(n(t)||k(),this instanceof O||M(),T(this,t))}var C;C=Array.isArray?Array.isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)};var R,x=C,D=(Date.now||function(){return(new Date).getTime()},Object.create||function(t){if(arguments.length>1)throw new Error(\"Second argument not supported\");if(\"object\"!=typeof t)throw new TypeError(\"Argument must be an object\");return r.prototype=t,new r},0),Y=function(t,n){K[D]=t,K[D+1]=n,D+=2,2===D&&R()},I=\"undefined\"!=typeof window?window:{},q=I.MutationObserver||I.WebKitMutationObserver,F=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel,K=new Array(1e3);R=\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process)?o():q?i():F?s():u();var N=void 0,U=1,W=2,$=new j,z=new j;S.prototype._validateInput=function(t){return x(t)},S.prototype._validationError=function(){return new Error(\"Array Methods must be provided an Array\")},S.prototype._init=function(){this._result=new Array(this.length)};var B=S;S.prototype._enumerate=function(){for(var t=this.length,n=this.promise,e=this._input,r=0;n._state===N&&r<t;r++)this._eachEntry(e[r],r)},S.prototype._eachEntry=function(t,n){var r=this._instanceConstructor;e(t)?t.constructor===r&&t._state!==N?(t._onerror=null,this._settledAt(t._state,n,t._result)):this._willSettleAt(r.resolve(t),n):(this._remaining--,this._result[n]=this._makeResult(U,n,t))},S.prototype._settledAt=function(t,n,e){var r=this.promise;r._state===N&&(this._remaining--,this._abortOnReject&&t===W?b(r,e):this._result[n]=this._makeResult(t,n,e)),0===this._remaining&&w(r,this._result)},S.prototype._makeResult=function(t,n,e){return e},S.prototype._willSettleAt=function(t,n){var e=this;g(t,void 0,function(t){e._settledAt(U,n,t)},function(t){e._settledAt(W,n,t)})};var G=function(t,n){return new B(this,t,!0,n).promise},H=function(t,n){function e(t){y(i,t)}function r(t){b(i,t)}var o=this,i=new o(a,n);if(!x(t))return b(i,new TypeError(\"You must pass an array to race.\")),i;for(var s=t.length,u=0;i._state===N&&u<s;u++)g(o.resolve(t[u]),void 0,e,r);return i},J=function(t,n){var e=this;if(t&&\"object\"==typeof t&&t.constructor===e)return t;var r=new e(a,n);return y(r,t),r},L=function(t,n){var e=this,r=new e(a,n);return b(r,t),r},Q=0,V=O;O.all=G,O.race=H,O.resolve=J,O.reject=L,O.prototype={constructor:O,then:function(t,n,e){var r=this,o=r._state;if(o===U&&!t||o===W&&!n)return this;r._onerror=null;var i=new this.constructor(a,e),s=r._result;if(o){var u=arguments[o-1];Y(function(){P(o,i,u,s)})}else g(r,i,t,n);return i},catch:function(t,n){return this.then(null,t,n)}};var X=function(){var t;t=\"undefined\"!=typeof global?global:\"undefined\"!=typeof window&&window.document?window:self;var e=\"Promise\"in t&&\"resolve\"in t.Promise&&\"reject\"in t.Promise&&\"all\"in t.Promise&&\"race\"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),n(e)}();e||(t.Promise=V)};X()}.call(this),n.exports._=r});\n//# sourceMappingURL=polyfill.promise.js.map","map":{"version":3,"file":"polyfill.promise.js","sources":["polyfill.promise.js"],"sourcesContent":["/** @module polyfill.promise */require( 'polyfill.promise', function(require, module, exports) { var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\r\n    /**\r\n * Polyfill for Promise...\r\n */\r\n/*!\r\n * @overview es6-promise - a tiny implementation of Promises/A+.\r\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\r\n * @license   Licensed under MIT license\r\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\r\n * @version   2.0.0\r\n */\r\n\r\nif (!window.Promise) {\r\n    (function() {\r\n        \"use strict\";\r\n\r\n        function $$utils$$objectOrFunction(x) {\r\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\r\n        }\r\n\r\n        function $$utils$$isFunction(x) {\r\n            return typeof x === 'function';\r\n        }\r\n\r\n        function $$utils$$isMaybeThenable(x) {\r\n            return typeof x === 'object' && x !== null;\r\n        }\r\n\r\n        var $$utils$$_isArray;\r\n\r\n        if (!Array.isArray) {\r\n            $$utils$$_isArray = function (x) {\r\n                return Object.prototype.toString.call(x) === '[object Array]';\r\n            };\r\n        } else {\r\n            $$utils$$_isArray = Array.isArray;\r\n        }\r\n\r\n        var $$utils$$isArray = $$utils$$_isArray;\r\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\r\n        function $$utils$$F() { }\r\n\r\n        var $$utils$$o_create = (Object.create || function (o) {\r\n            if (arguments.length > 1) {\r\n                throw new Error('Second argument not supported');\r\n            }\r\n            if (typeof o !== 'object') {\r\n                throw new TypeError('Argument must be an object');\r\n            }\r\n            $$utils$$F.prototype = o;\r\n            return new $$utils$$F();\r\n        });\r\n\r\n        var $$asap$$len = 0;\r\n\r\n        var $$asap$$default = function asap(callback, arg) {\r\n            $$asap$$queue[$$asap$$len] = callback;\r\n            $$asap$$queue[$$asap$$len + 1] = arg;\r\n            $$asap$$len += 2;\r\n            if ($$asap$$len === 2) {\r\n                // If len is 1, that means that we need to schedule an async flush.\r\n                // If additional callbacks are queued before the queue is flushed, they\r\n                // will be processed by this flush that we are scheduling.\r\n                $$asap$$scheduleFlush();\r\n            }\r\n        };\r\n\r\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\r\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\r\n\r\n        // test for web worker but not in IE10\r\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\r\n            typeof importScripts !== 'undefined' &&\r\n            typeof MessageChannel !== 'undefined';\r\n\r\n        // node\r\n        function $$asap$$useNextTick() {\r\n            return function() {\r\n                process.nextTick($$asap$$flush);\r\n            };\r\n        }\r\n\r\n        function $$asap$$useMutationObserver() {\r\n            var iterations = 0;\r\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\r\n            var node = document.createTextNode('');\r\n            observer.observe(node, { characterData: true });\r\n\r\n            return function() {\r\n                node.data = (iterations = ++iterations % 2);\r\n            };\r\n        }\r\n\r\n        // web worker\r\n        function $$asap$$useMessageChannel() {\r\n            var channel = new MessageChannel();\r\n            channel.port1.onmessage = $$asap$$flush;\r\n            return function () {\r\n                channel.port2.postMessage(0);\r\n            };\r\n        }\r\n\r\n        function $$asap$$useSetTimeout() {\r\n            return function() {\r\n                setTimeout($$asap$$flush, 1);\r\n            };\r\n        }\r\n\r\n        var $$asap$$queue = new Array(1000);\r\n\r\n        function $$asap$$flush() {\r\n            for (var i = 0; i < $$asap$$len; i+=2) {\r\n                var callback = $$asap$$queue[i];\r\n                var arg = $$asap$$queue[i+1];\r\n\r\n                callback(arg);\r\n\r\n                $$asap$$queue[i] = undefined;\r\n                $$asap$$queue[i+1] = undefined;\r\n            }\r\n\r\n            $$asap$$len = 0;\r\n        }\r\n\r\n        var $$asap$$scheduleFlush;\r\n\r\n        // Decide what async method to use to triggering processing of queued callbacks:\r\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\r\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\r\n        } else if ($$asap$$BrowserMutationObserver) {\r\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\r\n        } else if ($$asap$$isWorker) {\r\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\r\n        } else {\r\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\r\n        }\r\n\r\n        function $$$internal$$noop() {}\r\n        var $$$internal$$PENDING   = void 0;\r\n        var $$$internal$$FULFILLED = 1;\r\n        var $$$internal$$REJECTED  = 2;\r\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\r\n\r\n        function $$$internal$$selfFullfillment() {\r\n            return new TypeError(\"You cannot resolve a promise with itself\");\r\n        }\r\n\r\n        function $$$internal$$cannotReturnOwn() {\r\n            return new TypeError('A promises callback cannot return that same promise.')\r\n        }\r\n\r\n        function $$$internal$$getThen(promise) {\r\n            try {\r\n                return promise.then;\r\n            } catch(error) {\r\n                $$$internal$$GET_THEN_ERROR.error = error;\r\n                return $$$internal$$GET_THEN_ERROR;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\r\n            try {\r\n                then.call(value, fulfillmentHandler, rejectionHandler);\r\n            } catch(e) {\r\n                return e;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\r\n            $$asap$$default(function(promise) {\r\n                var sealed = false;\r\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\r\n                    if (sealed) { return; }\r\n                    sealed = true;\r\n                    if (thenable !== value) {\r\n                        $$$internal$$resolve(promise, value);\r\n                    } else {\r\n                        $$$internal$$fulfill(promise, value);\r\n                    }\r\n                }, function(reason) {\r\n                    if (sealed) { return; }\r\n                    sealed = true;\r\n\r\n                    $$$internal$$reject(promise, reason);\r\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\r\n\r\n                if (!sealed && error) {\r\n                    sealed = true;\r\n                    $$$internal$$reject(promise, error);\r\n                }\r\n            }, promise);\r\n        }\r\n\r\n        function $$$internal$$handleOwnThenable(promise, thenable) {\r\n            if (thenable._state === $$$internal$$FULFILLED) {\r\n                $$$internal$$fulfill(promise, thenable._result);\r\n            } else if (promise._state === $$$internal$$REJECTED) {\r\n                $$$internal$$reject(promise, thenable._result);\r\n            } else {\r\n                $$$internal$$subscribe(thenable, undefined, function(value) {\r\n                    $$$internal$$resolve(promise, value);\r\n                }, function(reason) {\r\n                    $$$internal$$reject(promise, reason);\r\n                });\r\n            }\r\n        }\r\n\r\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\r\n            if (maybeThenable.constructor === promise.constructor) {\r\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\r\n            } else {\r\n                var then = $$$internal$$getThen(maybeThenable);\r\n\r\n                if (then === $$$internal$$GET_THEN_ERROR) {\r\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\r\n                } else if (then === undefined) {\r\n                    $$$internal$$fulfill(promise, maybeThenable);\r\n                } else if ($$utils$$isFunction(then)) {\r\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\r\n                } else {\r\n                    $$$internal$$fulfill(promise, maybeThenable);\r\n                }\r\n            }\r\n        }\r\n\r\n        function $$$internal$$resolve(promise, value) {\r\n            if (promise === value) {\r\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\r\n            } else if ($$utils$$objectOrFunction(value)) {\r\n                $$$internal$$handleMaybeThenable(promise, value);\r\n            } else {\r\n                $$$internal$$fulfill(promise, value);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$publishRejection(promise) {\r\n            if (promise._onerror) {\r\n                promise._onerror(promise._result);\r\n            }\r\n\r\n            $$$internal$$publish(promise);\r\n        }\r\n\r\n        function $$$internal$$fulfill(promise, value) {\r\n            if (promise._state !== $$$internal$$PENDING) { return; }\r\n\r\n            promise._result = value;\r\n            promise._state = $$$internal$$FULFILLED;\r\n\r\n            if (promise._subscribers.length === 0) {\r\n            } else {\r\n                $$asap$$default($$$internal$$publish, promise);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$reject(promise, reason) {\r\n            if (promise._state !== $$$internal$$PENDING) { return; }\r\n            promise._state = $$$internal$$REJECTED;\r\n            promise._result = reason;\r\n\r\n            $$asap$$default($$$internal$$publishRejection, promise);\r\n        }\r\n\r\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\r\n            var subscribers = parent._subscribers;\r\n            var length = subscribers.length;\r\n\r\n            parent._onerror = null;\r\n\r\n            subscribers[length] = child;\r\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\r\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\r\n\r\n            if (length === 0 && parent._state) {\r\n                $$asap$$default($$$internal$$publish, parent);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$publish(promise) {\r\n            var subscribers = promise._subscribers;\r\n            var settled = promise._state;\r\n\r\n            if (subscribers.length === 0) { return; }\r\n\r\n            var child, callback, detail = promise._result;\r\n\r\n            for (var i = 0; i < subscribers.length; i += 3) {\r\n                child = subscribers[i];\r\n                callback = subscribers[i + settled];\r\n\r\n                if (child) {\r\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\r\n                } else {\r\n                    callback(detail);\r\n                }\r\n            }\r\n\r\n            promise._subscribers.length = 0;\r\n        }\r\n\r\n        function $$$internal$$ErrorObject() {\r\n            this.error = null;\r\n        }\r\n\r\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\r\n\r\n        function $$$internal$$tryCatch(callback, detail) {\r\n            try {\r\n                return callback(detail);\r\n            } catch(e) {\r\n                $$$internal$$TRY_CATCH_ERROR.error = e;\r\n                return $$$internal$$TRY_CATCH_ERROR;\r\n            }\r\n        }\r\n\r\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\r\n            var hasCallback = $$utils$$isFunction(callback),\r\n            value, error, succeeded, failed;\r\n\r\n            if (hasCallback) {\r\n                value = $$$internal$$tryCatch(callback, detail);\r\n\r\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\r\n                    failed = true;\r\n                    error = value.error;\r\n                    value = null;\r\n                } else {\r\n                    succeeded = true;\r\n                }\r\n\r\n                if (promise === value) {\r\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\r\n                    return;\r\n                }\r\n\r\n            } else {\r\n                value = detail;\r\n                succeeded = true;\r\n            }\r\n\r\n            if (promise._state !== $$$internal$$PENDING) {\r\n                // noop\r\n            } else if (hasCallback && succeeded) {\r\n                $$$internal$$resolve(promise, value);\r\n            } else if (failed) {\r\n                $$$internal$$reject(promise, error);\r\n            } else if (settled === $$$internal$$FULFILLED) {\r\n                $$$internal$$fulfill(promise, value);\r\n            } else if (settled === $$$internal$$REJECTED) {\r\n                $$$internal$$reject(promise, value);\r\n            }\r\n        }\r\n\r\n        function $$$internal$$initializePromise(promise, resolver) {\r\n            try {\r\n                resolver(function resolvePromise(value){\r\n                    $$$internal$$resolve(promise, value);\r\n                }, function rejectPromise(reason) {\r\n                    $$$internal$$reject(promise, reason);\r\n                });\r\n            } catch(e) {\r\n                $$$internal$$reject(promise, e);\r\n            }\r\n        }\r\n\r\n        function $$$enumerator$$makeSettledResult(state, position, value) {\r\n            if (state === $$$internal$$FULFILLED) {\r\n                return {\r\n                    state: 'fulfilled',\r\n                    value: value\r\n                };\r\n            } else {\r\n                return {\r\n                    state: 'rejected',\r\n                    reason: value\r\n                };\r\n            }\r\n        }\r\n\r\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\r\n            this._instanceConstructor = Constructor;\r\n            this.promise = new Constructor($$$internal$$noop, label);\r\n            this._abortOnReject = abortOnReject;\r\n\r\n            if (this._validateInput(input)) {\r\n                this._input     = input;\r\n                this.length     = input.length;\r\n                this._remaining = input.length;\r\n\r\n                this._init();\r\n\r\n                if (this.length === 0) {\r\n                    $$$internal$$fulfill(this.promise, this._result);\r\n                } else {\r\n                    this.length = this.length || 0;\r\n                    this._enumerate();\r\n                    if (this._remaining === 0) {\r\n                        $$$internal$$fulfill(this.promise, this._result);\r\n                    }\r\n                }\r\n            } else {\r\n                $$$internal$$reject(this.promise, this._validationError());\r\n            }\r\n        }\r\n\r\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\r\n            return $$utils$$isArray(input);\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\r\n            return new Error('Array Methods must be provided an Array');\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._init = function() {\r\n            this._result = new Array(this.length);\r\n        };\r\n\r\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\r\n\r\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\r\n            var length  = this.length;\r\n            var promise = this.promise;\r\n            var input   = this._input;\r\n\r\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\r\n                this._eachEntry(input[i], i);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\r\n            var c = this._instanceConstructor;\r\n            if ($$utils$$isMaybeThenable(entry)) {\r\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\r\n                    entry._onerror = null;\r\n                    this._settledAt(entry._state, i, entry._result);\r\n                } else {\r\n                    this._willSettleAt(c.resolve(entry), i);\r\n                }\r\n            } else {\r\n                this._remaining--;\r\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\r\n            var promise = this.promise;\r\n\r\n            if (promise._state === $$$internal$$PENDING) {\r\n                this._remaining--;\r\n\r\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\r\n                    $$$internal$$reject(promise, value);\r\n                } else {\r\n                    this._result[i] = this._makeResult(state, i, value);\r\n                }\r\n            }\r\n\r\n            if (this._remaining === 0) {\r\n                $$$internal$$fulfill(promise, this._result);\r\n            }\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\r\n            return value;\r\n        };\r\n\r\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\r\n            var enumerator = this;\r\n\r\n            $$$internal$$subscribe(promise, undefined, function(value) {\r\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\r\n            }, function(reason) {\r\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\r\n            });\r\n        };\r\n\r\n        var $$promise$all$$default = function all(entries, label) {\r\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\r\n        };\r\n\r\n        var $$promise$race$$default = function race(entries, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n\r\n            if (!$$utils$$isArray(entries)) {\r\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\r\n                return promise;\r\n            }\r\n\r\n            var length = entries.length;\r\n\r\n            function onFulfillment(value) {\r\n                $$$internal$$resolve(promise, value);\r\n            }\r\n\r\n            function onRejection(reason) {\r\n                $$$internal$$reject(promise, reason);\r\n            }\r\n\r\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\r\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\r\n            }\r\n\r\n            return promise;\r\n        };\r\n\r\n        var $$promise$resolve$$default = function resolve(object, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n\r\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\r\n                return object;\r\n            }\r\n\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n            $$$internal$$resolve(promise, object);\r\n            return promise;\r\n        };\r\n\r\n        var $$promise$reject$$default = function reject(reason, label) {\r\n            /*jshint validthis:true */\r\n            var Constructor = this;\r\n            var promise = new Constructor($$$internal$$noop, label);\r\n            $$$internal$$reject(promise, reason);\r\n            return promise;\r\n        };\r\n\r\n        var $$es6$promise$promise$$counter = 0;\r\n\r\n        function $$es6$promise$promise$$needsResolver() {\r\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\r\n        }\r\n\r\n        function $$es6$promise$promise$$needsNew() {\r\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\r\n        }\r\n\r\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\r\n\r\n        /**\r\n         Promise objects represent the eventual result of an asynchronous operation. The\r\n         primary way of interacting with a promise is through its `then` method, which\r\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\r\n         why the promise cannot be fulfilled.\r\n\r\n         Terminology\r\n         -----------\r\n\r\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\r\n         - `thenable` is an object or function that defines a `then` method.\r\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\r\n         - `exception` is a value that is thrown using the throw statement.\r\n         - `reason` is a value that indicates why a promise was rejected.\r\n         - `settled` the final resting state of a promise, fulfilled or rejected.\r\n\r\n         A promise can be in one of three states: pending, fulfilled, or rejected.\r\n\r\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\r\n         state.  Promises that are rejected have a rejection reason and are in the\r\n         rejected state.  A fulfillment value is never a thenable.\r\n\r\n         Promises can also be said to *resolve* a value.  If this value is also a\r\n         promise, then the original promise's settled state will match the value's\r\n         settled state.  So a promise that *resolves* a promise that rejects will\r\n         itself reject, and a promise that *resolves* a promise that fulfills will\r\n         itself fulfill.\r\n\r\n\r\n         Basic Usage:\r\n         ------------\r\n\r\n         ```js\r\n         var promise = new Promise(function(resolve, reject) {\r\n         // on success\r\n         resolve(value);\r\n\r\n         // on failure\r\n         reject(reason);\r\n         });\r\n\r\n         promise.then(function(value) {\r\n         // on fulfillment\r\n         }, function(reason) {\r\n         // on rejection\r\n         });\r\n         ```\r\n\r\n         Advanced Usage:\r\n         ---------------\r\n\r\n         Promises shine when abstracting away asynchronous interactions such as\r\n         `XMLHttpRequest`s.\r\n\r\n         ```js\r\n         function getJSON(url) {\r\n         return new Promise(function(resolve, reject){\r\n         var xhr = new XMLHttpRequest();\r\n\r\n         xhr.open('GET', url);\r\n         xhr.onreadystatechange = handler;\r\n         xhr.responseType = 'json';\r\n         xhr.setRequestHeader('Accept', 'application/json');\r\n         xhr.send();\r\n\r\n         function handler() {\r\n         if (this.readyState === this.DONE) {\r\n         if (this.status === 200) {\r\n         resolve(this.response);\r\n         } else {\r\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\r\n         }\r\n         }\r\n         };\r\n         });\r\n         }\r\n\r\n         getJSON('/posts.json').then(function(json) {\r\n         // on fulfillment\r\n         }, function(reason) {\r\n         // on rejection\r\n         });\r\n         ```\r\n\r\n         Unlike callbacks, promises are great composable primitives.\r\n\r\n         ```js\r\n         Promise.all([\r\n         getJSON('/posts'),\r\n         getJSON('/comments')\r\n         ]).then(function(values){\r\n         values[0] // => postsJSON\r\n         values[1] // => commentsJSON\r\n\r\n         return values;\r\n         });\r\n         ```\r\n\r\n         @class Promise\r\n         @param {function} resolver\r\n         @param {String} label optional string for labeling the promise.\r\n         Useful for tooling.\r\n         @constructor\r\n         */\r\n        function $$es6$promise$promise$$Promise(resolver, label) {\r\n            this._id = $$es6$promise$promise$$counter++;\r\n            this._label = label;\r\n            this._state = undefined;\r\n            this._result = undefined;\r\n            this._subscribers = [];\r\n\r\n            if ($$$internal$$noop !== resolver) {\r\n                if (!$$utils$$isFunction(resolver)) {\r\n                    $$es6$promise$promise$$needsResolver();\r\n                }\r\n\r\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\r\n                    $$es6$promise$promise$$needsNew();\r\n                }\r\n\r\n                $$$internal$$initializePromise(this, resolver);\r\n            }\r\n        }\r\n\r\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\r\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\r\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\r\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\r\n\r\n        $$es6$promise$promise$$Promise.prototype = {\r\n            constructor: $$es6$promise$promise$$Promise,\r\n\r\n            /**\r\n             The primary way of interacting with a promise is through its `then` method,\r\n             which registers callbacks to receive either a promise's eventual value or the\r\n             reason why the promise cannot be fulfilled.\r\n\r\n             ```js\r\n             findUser().then(function(user){\r\n             // user is available\r\n             }, function(reason){\r\n             // user is unavailable, and you are given the reason why\r\n             });\r\n             ```\r\n\r\n             Chaining\r\n             --------\r\n\r\n             The return value of `then` is itself a promise.  This second, 'downstream'\r\n             promise is resolved with the return value of the first promise's fulfillment\r\n             or rejection handler, or rejected if the handler throws an exception.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return user.name;\r\n             }, function (reason) {\r\n             return 'default name';\r\n             }).then(function (userName) {\r\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\r\n             // will be `'default name'`\r\n             });\r\n\r\n             findUser().then(function (user) {\r\n             throw new Error('Found user, but still unhappy');\r\n             }, function (reason) {\r\n             throw new Error('`findUser` rejected and we're unhappy');\r\n             }).then(function (value) {\r\n             // never reached\r\n             }, function (reason) {\r\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\r\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\r\n             });\r\n             ```\r\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             throw new PedagogicalException('Upstream error');\r\n             }).then(function (value) {\r\n             // never reached\r\n             }).then(function (value) {\r\n             // never reached\r\n             }, function (reason) {\r\n             // The `PedgagocialException` is propagated all the way down to here\r\n             });\r\n             ```\r\n\r\n             Assimilation\r\n             ------------\r\n\r\n             Sometimes the value you want to propagate to a downstream promise can only be\r\n             retrieved asynchronously. This can be achieved by returning a promise in the\r\n             fulfillment or rejection handler. The downstream promise will then be pending\r\n             until the returned promise is settled. This is called *assimilation*.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return findCommentsByAuthor(user);\r\n             }).then(function (comments) {\r\n             // The user's comments are now available\r\n             });\r\n             ```\r\n\r\n             If the assimliated promise rejects, then the downstream promise will also reject.\r\n\r\n             ```js\r\n             findUser().then(function (user) {\r\n             return findCommentsByAuthor(user);\r\n             }).then(function (comments) {\r\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\r\n             }, function (reason) {\r\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\r\n             });\r\n             ```\r\n\r\n             Simple Example\r\n             --------------\r\n\r\n             Synchronous Example\r\n\r\n             ```javascript\r\n             var result;\r\n\r\n             try {\r\n             result = findResult();\r\n             // success\r\n             } catch(reason) {\r\n             // failure\r\n             }\r\n             ```\r\n\r\n             Errback Example\r\n\r\n             ```js\r\n             findResult(function(result, err){\r\n             if (err) {\r\n             // failure\r\n             } else {\r\n             // success\r\n             }\r\n             });\r\n             ```\r\n\r\n             Promise Example;\r\n\r\n             ```javascript\r\n             findResult().then(function(result){\r\n             // success\r\n             }, function(reason){\r\n             // failure\r\n             });\r\n             ```\r\n\r\n             Advanced Example\r\n             --------------\r\n\r\n             Synchronous Example\r\n\r\n             ```javascript\r\n             var author, books;\r\n\r\n             try {\r\n             author = findAuthor();\r\n             books  = findBooksByAuthor(author);\r\n             // success\r\n             } catch(reason) {\r\n             // failure\r\n             }\r\n             ```\r\n\r\n             Errback Example\r\n\r\n             ```js\r\n\r\n             function foundBooks(books) {\r\n\r\n             }\r\n\r\n             function failure(reason) {\r\n\r\n             }\r\n\r\n             findAuthor(function(author, err){\r\n             if (err) {\r\n             failure(err);\r\n             // failure\r\n             } else {\r\n             try {\r\n             findBoooksByAuthor(author, function(books, err) {\r\n             if (err) {\r\n             failure(err);\r\n             } else {\r\n             try {\r\n             foundBooks(books);\r\n             } catch(reason) {\r\n             failure(reason);\r\n             }\r\n             }\r\n             });\r\n             } catch(error) {\r\n             failure(err);\r\n             }\r\n             // success\r\n             }\r\n             });\r\n             ```\r\n\r\n             Promise Example;\r\n\r\n             ```javascript\r\n             findAuthor().\r\n             then(findBooksByAuthor).\r\n             then(function(books){\r\n             // found books\r\n             }).catch(function(reason){\r\n             // something went wrong\r\n             });\r\n             ```\r\n\r\n             @method then\r\n             @param {Function} onFulfilled\r\n             @param {Function} onRejected\r\n             @param {String} label optional string for labeling the promise.\r\n             Useful for tooling.\r\n             @return {Promise}\r\n             */\r\n            then: function(onFulfillment, onRejection, label) {\r\n                var parent = this;\r\n                var state = parent._state;\r\n\r\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\r\n                    return this;\r\n                }\r\n\r\n                parent._onerror = null;\r\n\r\n                var child = new this.constructor($$$internal$$noop, label);\r\n                var result = parent._result;\r\n\r\n                if (state) {\r\n                    var callback = arguments[state - 1];\r\n                    $$asap$$default(function(){\r\n                        $$$internal$$invokeCallback(state, child, callback, result);\r\n                    });\r\n                } else {\r\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\r\n                }\r\n\r\n                return child;\r\n            },\r\n\r\n            /**\r\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\r\n             as the catch block of a try/catch statement.\r\n\r\n             ```js\r\n             function findAuthor(){\r\n             throw new Error('couldn't find that author');\r\n             }\r\n\r\n             // synchronous\r\n             try {\r\n             findAuthor();\r\n             } catch(reason) {\r\n             // something went wrong\r\n             }\r\n\r\n             // async with promises\r\n             findAuthor().catch(function(reason){\r\n             // something went wrong\r\n             });\r\n             ```\r\n\r\n             @method catch\r\n             @param {Function} onRejection\r\n             @param {String} label optional string for labeling the promise.\r\n             Useful for tooling.\r\n             @return {Promise}\r\n             */\r\n            'catch': function(onRejection, label) {\r\n                return this.then(null, onRejection, label);\r\n            }\r\n        };\r\n\r\n        var $$es6$promise$polyfill$$default = function polyfill() {\r\n            var local;\r\n\r\n            if (typeof global !== 'undefined') {\r\n                local = global;\r\n            } else if (typeof window !== 'undefined' && window.document) {\r\n                local = window;\r\n            } else {\r\n                local = self;\r\n            }\r\n\r\n            var es6PromiseSupport =\r\n                \"Promise\" in local &&\r\n                // Some of these methods are missing from\r\n                // Firefox/Chrome experimental implementations\r\n                \"resolve\" in local.Promise &&\r\n                \"reject\" in local.Promise &&\r\n                \"all\" in local.Promise &&\r\n                \"race\" in local.Promise &&\r\n                // Older version of the spec had a resolver object\r\n                // as the arg rather than a function\r\n                (function() {\r\n                    var resolve;\r\n                    new local.Promise(function(r) { resolve = r; });\r\n                    return $$utils$$isFunction(resolve);\r\n                }());\r\n\r\n            if (!es6PromiseSupport) {\r\n                local.Promise = $$es6$promise$promise$$default;\r\n            }\r\n        };\r\n\r\n        var es6$promise$umd$$ES6Promise = {\r\n            Promise: $$es6$promise$promise$$default,\r\n            polyfill: $$es6$promise$polyfill$$default\r\n        };\r\n\r\n        // Calling polyfill.\r\n        $$es6$promise$polyfill$$default();\r\n\r\n        /* global define:true module:true window: true */\r\n/*\r\n        if (typeof define === 'function' && define['amd']) {\r\n            define(function() { return es6$promise$umd$$ES6Promise; });\r\n        } else if (typeof module !== 'undefined' && module['exports']) {\r\n            module['exports'] = es6$promise$umd$$ES6Promise;\r\n        } else if (typeof this !== 'undefined') {\r\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\r\n        }\r\n*/\r\n    }).call(this);\r\n}\r\n\r\n\r\n  \r\nmodule.exports._ = _;\n});"],"names":["require","module","exports","_","X","D","arguments","en","fr","intl","all","window","Promise","$$utils$$objectOrFunction","x","$$utils$$isFunction","$$utils$$isMaybeThenable","$$utils$$F","$$asap$$useNextTick","process","nextTick","$$asap$$flush","$$asap$$useMutationObserver","iterations","observer","$$asap$$BrowserMutationObserver","node","document","createTextNode","observe","characterData","data","$$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","$$asap$$useSetTimeout","setTimeout","i","$$asap$$len","callback","$$asap$$queue","arg","undefined","$$$internal$$noop","$$$internal$$selfFullfillment","TypeError","$$$internal$$cannotReturnOwn","$$$internal$$getThen","promise","then","error","$$$internal$$GET_THEN_ERROR","$$$internal$$tryThen","value","fulfillmentHandler","rejectionHandler","call","e","$$$internal$$handleForeignThenable","thenable","$$asap$$default","sealed","$$$internal$$resolve","$$$internal$$fulfill","reason","$$$internal$$reject","_label","$$$internal$$handleOwnThenable","_state","$$$internal$$FULFILLED","_result","$$$internal$$REJECTED","$$$internal$$subscribe","$$$internal$$handleMaybeThenable","maybeThenable","constructor","$$$internal$$publishRejection","_onerror","$$$internal$$publish","$$$internal$$PENDING","_subscribers","length","parent","child","onFulfillment","onRejection","subscribers","settled","detail","$$$internal$$invokeCallback","$$$internal$$ErrorObject","this","$$$internal$$tryCatch","$$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","$$$internal$$initializePromise","resolver","$$$enumerator$$Enumerator","Constructor","input","abortOnReject","label","_instanceConstructor","_abortOnReject","_validateInput","_input","_remaining","_init","_enumerate","_validationError","$$es6$promise$promise$$needsResolver","$$es6$promise$promise$$needsNew","$$es6$promise$promise$$Promise","_id","$$es6$promise$promise$$counter","$$utils$$_isArray","Array","isArray","Object","prototype","toString","$$asap$$scheduleFlush","$$utils$$isArray","Date","now","getTime","create","o","Error","$$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","$$asap$$isWorker","Uint8ClampedArray","importScripts","$$$enumerator$$default","_eachEntry","entry","c","_settledAt","_willSettleAt","resolve","_makeResult","state","enumerator","$$promise$all$$default","entries","$$promise$race$$default","$$promise$resolve$$default","object","$$promise$reject$$default","$$es6$promise$promise$$default","race","reject","result","catch","$$es6$promise$polyfill$$default","local","global","self","es6PromiseSupport","r"],"mappings":"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"},"dependencies":["mod/$"]}